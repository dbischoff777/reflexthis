{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration",
        "description": "Initialize Next.js project with TypeScript, shadcn/ui, and Tailwind CSS. Set up project structure, routing, and base configuration.",
        "details": "1. Create a new Next.js project using the App Router:\n```bash\nnpx create-next-app@latest reflexthis --typescript --tailwind --eslint --app\n```\n2. Install and configure shadcn/ui:\n```bash\nnpx shadcn-ui@latest init\n```\n3. Set up project structure with the following directories:\n   - `/app`: For Next.js App Router pages\n   - `/components`: For reusable UI components\n   - `/lib`: For utility functions and game logic\n   - `/styles`: For global styles\n   - `/public`: For static assets\n4. Configure Tailwind with cyberpunk-inspired color palette:\n```js\n// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        primary: '#0ff',\n        secondary: '#f0f',\n        accent: '#00f0ff',\n        background: '#0a0a0f',\n        surface: '#1a1a2e'\n      }\n    }\n  }\n}\n```\n5. Set up ESLint with strict TypeScript rules\n6. Configure environment variables for development/production\n7. Create build information utility to display version and build date",
        "testStrategy": "1. Verify project structure is correctly set up\n2. Ensure all dependencies are installed and working\n3. Test build process works without errors\n4. Verify TypeScript strict mode is enabled\n5. Test that shadcn/ui components can be imported and used\n6. Confirm Tailwind CSS is properly configured with custom colors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Landing Page Implementation",
        "description": "Create the landing page with welcome message, start game button, and build information display.",
        "details": "1. Create `/app/page.tsx` for the landing page:\n```tsx\nexport default function LandingPage() {\n  return (\n    <div className=\"min-h-screen flex flex-col items-center justify-center bg-background text-white p-4\">\n      <h1 className=\"text-4xl md:text-6xl font-bold text-primary mb-6\">ReflexThis</h1>\n      <p className=\"text-xl mb-8 text-center\">Test your reflexes in this cyberpunk-inspired game</p>\n      <Link href=\"/game\" className=\"btn-primary text-xl py-3 px-8 rounded-full bg-gradient-to-r from-primary to-secondary hover:shadow-glow transition-all duration-300\">\n        Start Game\n      </Link>\n      <BuildInfo className=\"absolute bottom-4 text-sm opacity-70\" />\n    </div>\n  );\n}\n```\n\n2. Create a `BuildInfo` component to display version and build date:\n```tsx\nexport function BuildInfo({ className }: { className?: string }) {\n  return (\n    <div className={className}>\n      <p>v1.0.0 | Built: {process.env.NEXT_PUBLIC_BUILD_DATE || new Date().toISOString().split('T')[0]}</p>\n    </div>\n  );\n}\n```\n\n3. Add cyberpunk-inspired background with subtle animation effects\n4. Implement responsive design for both portrait and landscape orientations\n5. Add smooth hover/focus states for the start button with glow effects",
        "testStrategy": "1. Verify landing page renders correctly on mobile devices\n2. Test responsive design in both portrait and landscape orientations\n3. Ensure Start Game button is properly sized for touch interactions (min 44x44px)\n4. Verify build information is displayed correctly\n5. Test navigation to game page works when Start Game is pressed\n6. Verify visual design matches cyberpunk aesthetic requirements",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Game Layout and Button Grid",
        "description": "Implement the game page layout with the 3-4-3 button grid, header with score/lives display, and basic styling.",
        "details": "1. Create `/app/game/page.tsx` for the game page:\n```tsx\n'use client';\n\nexport default function GamePage() {\n  return (\n    <div className=\"min-h-screen bg-background text-white flex flex-col\">\n      <header className=\"p-4 flex justify-between items-center\">\n        <div className=\"score-display\">Score: 0</div>\n        <div className=\"lives-display\">Lives: 5</div>\n        <div className=\"controls\">\n          <button className=\"sound-toggle\">üîä</button>\n          <Link href=\"/\" className=\"ml-4\">‚úï</Link>\n        </div>\n      </header>\n      \n      <main className=\"flex-1 flex items-center justify-center p-4\">\n        <div className=\"button-grid\">\n          <div className=\"grid-row top-row\">\n            {[1, 2, 3].map(id => (\n              <GameButton key={id} id={id} />\n            ))}\n          </div>\n          <div className=\"grid-row middle-row\">\n            {[4, 5, 6, 7].map(id => (\n              <GameButton key={id} id={id} />\n            ))}\n          </div>\n          <div className=\"grid-row bottom-row\">\n            {[8, 9, 10].map(id => (\n              <GameButton key={id} id={id} />\n            ))}\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n}\n```\n\n2. Create the `GameButton` component:\n```tsx\ninterface GameButtonProps {\n  id: number;\n  highlighted?: boolean;\n  onPress?: () => void;\n}\n\nexport function GameButton({ id, highlighted = false, onPress }: GameButtonProps) {\n  return (\n    <button\n      className={`game-button w-16 h-16 md:w-20 md:h-20 rounded-full m-2 transition-all duration-300 ${highlighted ? 'bg-primary shadow-glow animate-pulse' : 'bg-surface'}`}\n      onClick={onPress}\n    >\n      {/* Optional: Button content */}\n    </button>\n  );\n}\n```\n\n3. Style the button grid with CSS for the 3-4-3 layout:\n```css\n.button-grid {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.grid-row {\n  display: flex;\n  justify-content: center;\n  gap: 1rem;\n}\n\n.shadow-glow {\n  box-shadow: 0 0 15px 5px rgba(0, 255, 255, 0.7);\n}\n\n@keyframes pulse {\n  0%, 100% { transform: scale(1); opacity: 1; }\n  50% { transform: scale(1.05); opacity: 0.9; }\n}\n\n.animate-pulse {\n  animation: pulse 1.5s infinite;\n}\n```\n\n4. Implement responsive design for landscape orientation\n5. Add media queries to handle different screen sizes\n6. Ensure buttons are properly sized for touch interactions",
        "testStrategy": "1. Verify game layout renders correctly on mobile devices in landscape orientation\n2. Test that all 10 buttons are rendered in the correct 3-4-3 grid pattern\n3. Verify header displays score and lives correctly\n4. Test button styling and ensure they're large enough for touch (min 44x44px)\n5. Verify the layout is responsive and adjusts to different screen sizes\n6. Test that the quit button returns to landing page\n7. Verify visual design matches cyberpunk aesthetic requirements",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Game State Management",
        "description": "Implement game state management for tracking score, lives, button states, and game status.",
        "details": "1. Create a game state context and provider:\n```tsx\n// lib/GameContext.tsx\nimport { createContext, useContext, useState, useEffect, ReactNode } from 'react';\n\ninterface GameState {\n  score: number;\n  lives: number;\n  highlightedButtons: number[];\n  gameOver: boolean;\n  soundEnabled: boolean;\n  toggleSound: () => void;\n  incrementScore: () => void;\n  decrementLives: () => void;\n  setHighlightedButtons: (buttonIds: number[]) => void;\n  resetGame: () => void;\n}\n\nconst GameContext = createContext<GameState | undefined>(undefined);\n\nexport function GameProvider({ children }: { children: ReactNode }) {\n  const [score, setScore] = useState(0);\n  const [lives, setLives] = useState(5);\n  const [highlightedButtons, setHighlightedButtons] = useState<number[]>([]);\n  const [gameOver, setGameOver] = useState(false);\n  const [soundEnabled, setSoundEnabled] = useState(true);\n  \n  // Load sound preference from localStorage\n  useEffect(() => {\n    const savedSound = localStorage.getItem('soundEnabled');\n    if (savedSound !== null) {\n      setSoundEnabled(savedSound === 'true');\n    }\n  }, []);\n  \n  // Save sound preference to localStorage\n  const toggleSound = () => {\n    const newValue = !soundEnabled;\n    setSoundEnabled(newValue);\n    localStorage.setItem('soundEnabled', String(newValue));\n  };\n  \n  const incrementScore = () => setScore(prev => prev + 1);\n  \n  const decrementLives = () => {\n    setLives(prev => {\n      const newLives = prev - 1;\n      if (newLives <= 0) {\n        setGameOver(true);\n      }\n      return newLives;\n    });\n  };\n  \n  const resetGame = () => {\n    setScore(0);\n    setLives(5);\n    setHighlightedButtons([]);\n    setGameOver(false);\n  };\n  \n  return (\n    <GameContext.Provider value={{\n      score,\n      lives,\n      highlightedButtons,\n      gameOver,\n      soundEnabled,\n      toggleSound,\n      incrementScore,\n      decrementLives,\n      setHighlightedButtons,\n      resetGame\n    }}>\n      {children}\n    </GameContext.Provider>\n  );\n}\n\nexport function useGameState() {\n  const context = useContext(GameContext);\n  if (context === undefined) {\n    throw new Error('useGameState must be used within a GameProvider');\n  }\n  return context;\n}\n```\n\n2. Wrap the game page with the provider:\n```tsx\n// app/game/layout.tsx\nimport { GameProvider } from '@/lib/GameContext';\n\nexport default function GameLayout({ children }: { children: React.ReactNode }) {\n  return <GameProvider>{children}</GameProvider>;\n}\n```\n\n3. Update the game page to use the context:\n```tsx\n'use client';\nimport { useGameState } from '@/lib/GameContext';\n\nexport default function GamePage() {\n  const { score, lives, soundEnabled, toggleSound } = useGameState();\n  \n  return (\n    <div className=\"min-h-screen bg-background text-white flex flex-col\">\n      <header className=\"p-4 flex justify-between items-center\">\n        <div className=\"score-display\">Score: {score}</div>\n        <div className=\"lives-display\">Lives: {lives}</div>\n        <div className=\"controls\">\n          <button onClick={toggleSound} className=\"sound-toggle\">\n            {soundEnabled ? 'üîä' : 'üîá'}\n          </button>\n          <Link href=\"/\" className=\"ml-4\">‚úï</Link>\n        </div>\n      </header>\n      \n      {/* Rest of the game UI */}\n    </div>\n  );\n}\n```\n\n4. Implement a game over modal component that appears when lives reach 0\n5. Add local storage for saving high scores",
        "testStrategy": "1. Test that score increments correctly when called\n2. Verify lives decrement correctly and trigger game over when reaching 0\n3. Test that sound preference is saved to localStorage\n4. Verify game state resets correctly when resetGame is called\n5. Test that highlighted buttons state updates correctly\n6. Verify game over modal appears when lives reach 0\n7. Test that high scores are saved to localStorage\n8. Verify all state changes trigger appropriate re-renders",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Button Highlighting System",
        "description": "Implement the core game mechanic of randomly highlighting buttons and handling player interactions.",
        "details": "1. Create a utility for random button selection:\n```tsx\n// lib/gameUtils.ts\nexport function getRandomButtons(count: number, totalButtons: number, exclude: number[] = []) {\n  const availableButtons = Array.from(\n    { length: totalButtons },\n    (_, i) => i + 1\n  ).filter(id => !exclude.includes(id));\n  \n  const result: number[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    if (availableButtons.length === 0) break;\n    \n    const randomIndex = Math.floor(Math.random() * availableButtons.length);\n    const selectedButton = availableButtons[randomIndex];\n    \n    result.push(selectedButton);\n    availableButtons.splice(randomIndex, 1);\n  }\n  \n  return result;\n}\n\nexport function getButtonsToHighlight(score: number) {\n  // Determine how many buttons to highlight based on score\n  if (score <= 50) return 1; // Level 1: 1 button\n  if (score <= 150) return Math.random() < 0.5 ? 1 : 2; // Level 2: 1-2 buttons\n  return Math.floor(Math.random() * 3) + 1; // Level 3: 1-3 buttons\n}\n\nexport function getHighlightDuration(score: number) {\n  // Base duration: 2000ms\n  const baseDuration = 2000;\n  const minDuration = 300;\n  \n  let speedReduction = 0;\n  if (score <= 50) speedReduction = 0; // Base speed\n  else if (score <= 100) speedReduction = 0.1; // 10% faster\n  else if (score <= 200) speedReduction = 0.2; // 20% faster\n  else speedReduction = Math.min(0.7, 0.2 + (score - 200) * 0.001); // Up to 70% faster\n  \n  const duration = baseDuration * (1 - speedReduction);\n  return Math.max(minDuration, duration);\n}\n```\n\n2. Implement the game loop in the game page:\n```tsx\n'use client';\nimport { useGameState } from '@/lib/GameContext';\nimport { useEffect, useRef, useCallback } from 'react';\nimport { getRandomButtons, getButtonsToHighlight, getHighlightDuration } from '@/lib/gameUtils';\n\nexport default function GamePage() {\n  const {\n    score,\n    lives,\n    highlightedButtons,\n    gameOver,\n    setHighlightedButtons,\n    incrementScore,\n    decrementLives,\n    resetGame\n  } = useGameState();\n  \n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const lastHighlightedRef = useRef<number[]>([]);\n  \n  const clearHighlightTimer = () => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  };\n  \n  const highlightNewButtons = useCallback(() => {\n    if (gameOver) return;\n    \n    clearHighlightTimer();\n    \n    const buttonCount = getButtonsToHighlight(score);\n    const newHighlighted = getRandomButtons(buttonCount, 10, lastHighlightedRef.current);\n    lastHighlightedRef.current = newHighlighted;\n    \n    setHighlightedButtons(newHighlighted);\n    \n    // Set timer to clear highlight and penalize if not pressed in time\n    const duration = getHighlightDuration(score);\n    timerRef.current = setTimeout(() => {\n      setHighlightedButtons([]);\n      decrementLives();\n      \n      // Schedule next highlight after a short delay\n      setTimeout(highlightNewButtons, 1000);\n    }, duration);\n  }, [score, gameOver, setHighlightedButtons, decrementLives]);\n  \n  // Handle button press\n  const handleButtonPress = useCallback((buttonId: number) => {\n    if (gameOver || !highlightedButtons.length) return;\n    \n    if (highlightedButtons.includes(buttonId)) {\n      // Correct button pressed\n      incrementScore();\n      \n      // Remove this button from highlighted buttons\n      const updatedHighlighted = highlightedButtons.filter(id => id !== buttonId);\n      setHighlightedButtons(updatedHighlighted);\n      \n      // If all highlighted buttons are pressed, highlight new ones\n      if (updatedHighlighted.length === 0) {\n        clearHighlightTimer();\n        setTimeout(highlightNewButtons, 500);\n      }\n    } else {\n      // Wrong button pressed\n      decrementLives();\n    }\n  }, [highlightedButtons, gameOver, incrementScore, setHighlightedButtons, decrementLives, highlightNewButtons]);\n  \n  // Start game when component mounts\n  useEffect(() => {\n    highlightNewButtons();\n    \n    return () => clearHighlightTimer();\n  }, [highlightNewButtons]);\n  \n  // Update GameButton component to use the handleButtonPress function\n  // and check if it's highlighted\n  \n  return (\n    <div className=\"min-h-screen bg-background text-white flex flex-col\">\n      {/* Header and game UI */}\n      <main className=\"flex-1 flex items-center justify-center p-4\">\n        <div className=\"button-grid\">\n          {/* Button grid with updated GameButton components */}\n          <div className=\"grid-row top-row\">\n            {[1, 2, 3].map(id => (\n              <GameButton\n                key={id}\n                id={id}\n                highlighted={highlightedButtons.includes(id)}\n                onPress={() => handleButtonPress(id)}\n              />\n            ))}\n          </div>\n          {/* Middle and bottom rows similarly */}\n        </div>\n      </main>\n      \n      {gameOver && <GameOverModal score={score} onRestart={resetGame} />}\n    </div>\n  );\n}\n```\n\n3. Update the GameButton component to handle touch events optimally:\n```tsx\nfunction GameButton({ id, highlighted, onPress }: GameButtonProps) {\n  // Debounce button press to prevent accidental double-taps\n  const handlePress = useCallback(() => {\n    if (onPress) onPress();\n  }, [onPress]);\n  \n  return (\n    <button\n      className={`game-button w-16 h-16 md:w-20 md:h-20 rounded-full m-2 transition-all duration-300 \n        ${highlighted ? 'bg-primary shadow-glow animate-pulse' : 'bg-surface hover:bg-surface/80'}`}\n      onClick={handlePress}\n      aria-label={`Game button ${id}`}\n    />\n  );\n}\n```\n\n4. Implement touch event optimization to reduce delay on mobile devices\n5. Add debouncing to prevent button spam",
        "testStrategy": "1. Test that buttons highlight randomly according to the specified algorithm\n2. Verify that the number of highlighted buttons increases with score as specified\n3. Test that highlight duration decreases as score increases\n4. Verify correct button presses increment score and clear highlights\n5. Test that incorrect button presses decrement lives\n6. Verify that not pressing buttons in time decrements lives\n7. Test the debounce functionality prevents button spam\n8. Verify touch events work correctly on mobile devices with minimal delay",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Sound System Implementation",
        "description": "Implement sound effects for button highlights, successful/failed presses, life lost, and game over events.",
        "details": "1. Create a sound utility module:\n```tsx\n// lib/soundUtils.ts\nconst audioCache: Record<string, HTMLAudioElement> = {};\n\nconst SOUNDS = {\n  highlight: '/sounds/highlight.mp3',\n  success: '/sounds/success.mp3',\n  error: '/sounds/error.mp3',\n  lifeLost: '/sounds/life-lost.mp3',\n  gameOver: '/sounds/game-over.mp3'\n};\n\nexport function preloadSounds() {\n  if (typeof window === 'undefined') return;\n  \n  Object.entries(SOUNDS).forEach(([key, path]) => {\n    const audio = new Audio(path);\n    audio.preload = 'auto';\n    audioCache[key] = audio;\n  });\n}\n\nexport function playSound(sound: keyof typeof SOUNDS, enabled: boolean = true) {\n  if (!enabled || typeof window === 'undefined') return;\n  \n  try {\n    // Get from cache or create new\n    const audio = audioCache[sound] || new Audio(SOUNDS[sound]);\n    \n    // Reset and play\n    audio.currentTime = 0;\n    audio.play().catch(err => console.error('Error playing sound:', err));\n    \n    // Cache for future use\n    if (!audioCache[sound]) {\n      audioCache[sound] = audio;\n    }\n  } catch (error) {\n    console.error('Error playing sound:', error);\n  }\n}\n```\n\n2. Update the game state context to include sound functionality:\n```tsx\n// In GameProvider component\nimport { playSound, preloadSounds } from '@/lib/soundUtils';\n\nexport function GameProvider({ children }: { children: ReactNode }) {\n  // Existing state...\n  \n  // Preload sounds on mount\n  useEffect(() => {\n    preloadSounds();\n  }, []);\n  \n  const incrementScore = () => {\n    setScore(prev => prev + 1);\n    playSound('success', soundEnabled);\n  };\n  \n  const decrementLives = () => {\n    setLives(prev => {\n      const newLives = prev - 1;\n      if (newLives <= 0) {\n        setGameOver(true);\n        playSound('gameOver', soundEnabled);\n      } else {\n        playSound('lifeLost', soundEnabled);\n      }\n      return newLives;\n    });\n  };\n  \n  // Update other methods to play appropriate sounds\n  \n  return (\n    <GameContext.Provider value={/* ... */}>\n      {children}\n    </GameContext.Provider>\n  );\n}\n```\n\n3. Update the button highlighting system to play sounds:\n```tsx\n// In GamePage component\nconst highlightNewButtons = useCallback(() => {\n  // Existing code...\n  \n  setHighlightedButtons(newHighlighted);\n  playSound('highlight', soundEnabled);\n  \n  // Rest of the function...\n}, [/* dependencies */]);\n\nconst handleButtonPress = useCallback((buttonId: number) => {\n  if (gameOver || !highlightedButtons.length) return;\n  \n  if (highlightedButtons.includes(buttonId)) {\n    // Correct button - sound is played in incrementScore\n    incrementScore();\n    // Rest of the function...\n  } else {\n    // Wrong button - sound is played in decrementLives\n    decrementLives();\n  }\n}, [/* dependencies */]);\n```\n\n4. Create sound files for each event (highlight, success, error, life lost, game over)\n5. Add a sound toggle button in the header\n6. Implement sound preloading to minimize latency",
        "testStrategy": "1. Verify all sound effects play correctly for their respective events\n2. Test that sound toggle button correctly enables/disables sounds\n3. Verify sound preference is saved to localStorage\n4. Test sound preloading works correctly\n5. Verify sounds don't cause performance issues on mobile devices\n6. Test that sounds play with minimal latency\n7. Verify error handling works if sound files fail to load",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Game Over Screen Implementation",
        "description": "Create the game over screen/modal that displays final score and provides options to restart or return to the landing page.",
        "details": "1. Create a GameOverModal component:\n```tsx\n// components/GameOverModal.tsx\nimport { Button } from '@/components/ui/button';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '@/components/ui/dialog';\nimport Link from 'next/link';\n\ninterface GameOverModalProps {\n  score: number;\n  onRestart: () => void;\n}\n\nexport function GameOverModal({ score, onRestart }: GameOverModalProps) {\n  // Check if this is a new high score\n  const isHighScore = checkHighScore(score);\n  \n  // Save high score if applicable\n  useEffect(() => {\n    if (isHighScore) {\n      saveHighScore(score);\n    }\n  }, [score, isHighScore]);\n  \n  return (\n    <Dialog open={true}>\n      <DialogContent className=\"bg-surface text-white border-primary max-w-md mx-auto\">\n        <DialogHeader>\n          <DialogTitle className=\"text-2xl text-center text-primary\">Game Over</DialogTitle>\n          <DialogDescription className=\"text-center text-white/80\">\n            Your reflexes have been tested!\n          </DialogDescription>\n        </DialogHeader>\n        \n        <div className=\"py-6 text-center\">\n          <h3 className=\"text-xl mb-2\">Final Score</h3>\n          <p className=\"text-4xl font-bold text-primary mb-4\">{score}</p>\n          \n          {isHighScore && (\n            <div className=\"mb-4 p-2 bg-primary/20 rounded-md\">\n              <p className=\"text-primary font-bold\">New High Score! üèÜ</p>\n            </div>\n          )}\n          \n          <div className=\"mt-6 flex flex-col gap-3\">\n            <Button \n              onClick={onRestart}\n              className=\"w-full bg-primary hover:bg-primary/80 text-black font-bold py-3\"\n            >\n              Play Again\n            </Button>\n            \n            <Link href=\"/\" className=\"w-full\">\n              <Button \n                variant=\"outline\" \n                className=\"w-full border-primary text-primary hover:bg-primary/20 py-3\"\n              >\n                Back to Home\n              </Button>\n            </Link>\n          </div>\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\n// Utility functions for high score\nfunction checkHighScore(score: number): boolean {\n  if (typeof window === 'undefined') return false;\n  \n  const highScore = localStorage.getItem('highScore');\n  return !highScore || score > parseInt(highScore, 10);\n}\n\nfunction saveHighScore(score: number): void {\n  if (typeof window === 'undefined') return;\n  \n  localStorage.setItem('highScore', score.toString());\n}\n```\n\n2. Update the GamePage component to show the modal when game is over:\n```tsx\n// In GamePage component\nreturn (\n  <div className=\"min-h-screen bg-background text-white flex flex-col\">\n    {/* Game UI */}\n    \n    {gameOver && <GameOverModal score={score} onRestart={resetGame} />}\n  </div>\n);\n```\n\n3. Add animations for the game over modal appearance\n4. Implement high score tracking using localStorage\n5. Add confetti or special effects for new high scores",
        "testStrategy": "1. Verify game over modal appears when lives reach 0\n2. Test that final score is displayed correctly\n3. Verify high score detection and storage works correctly\n4. Test that Play Again button correctly resets the game\n5. Verify Back to Home button navigates to landing page\n6. Test animations and transitions for modal appearance\n7. Verify special effects for high scores work correctly\n8. Test modal appearance and functionality on different screen sizes",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Cyberpunk UI Styling and Animations",
        "description": "Implement the cyberpunk-inspired UI styling, animations, and visual effects throughout the game.",
        "details": "1. Create a global CSS file with cyberpunk theme variables and animations:\n```css\n/* styles/globals.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n:root {\n  --primary: #0ff;\n  --secondary: #f0f;\n  --accent: #00f0ff;\n  --background: #0a0a0f;\n  --surface: #1a1a2e;\n}\n\n@layer base {\n  body {\n    @apply bg-background text-white;\n    font-family: 'Rajdhani', 'Inter', sans-serif;\n  }\n}\n\n@layer components {\n  .shadow-glow {\n    box-shadow: 0 0 15px 5px rgba(0, 255, 255, 0.7);\n  }\n  \n  .text-glow {\n    text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);\n  }\n  \n  .border-glow {\n    box-shadow: 0 0 5px 2px rgba(0, 255, 255, 0.5);\n  }\n  \n  .btn-primary {\n    @apply bg-primary text-black font-bold rounded-md px-4 py-2;\n    position: relative;\n    overflow: hidden;\n  }\n  \n  .btn-primary::after {\n    content: '';\n    position: absolute;\n    top: -50%;\n    left: -50%;\n    width: 200%;\n    height: 200%;\n    background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);\n    transform: rotate(30deg);\n    animation: shine 3s infinite;\n  }\n  \n  @keyframes shine {\n    0% { transform: translateX(-100%) rotate(30deg); }\n    100% { transform: translateX(100%) rotate(30deg); }\n  }\n  \n  @keyframes pulse {\n    0%, 100% { transform: scale(1); opacity: 1; }\n    50% { transform: scale(1.05); opacity: 0.9; }\n  }\n  \n  .animate-pulse {\n    animation: pulse 1.5s infinite;\n  }\n  \n  .game-button {\n    position: relative;\n    transition: all 0.3s ease;\n  }\n  \n  .game-button::before {\n    content: '';\n    position: absolute;\n    inset: -2px;\n    border-radius: 50%;\n    background: linear-gradient(45deg, var(--primary), var(--secondary));\n    opacity: 0;\n    transition: opacity 0.3s ease;\n  }\n  \n  .game-button:hover::before,\n  .game-button:focus::before {\n    opacity: 0.5;\n  }\n}\n```\n\n2. Add cyberpunk-inspired fonts:\n```tsx\n// app/layout.tsx\nimport { Rajdhani } from 'next/font/google';\n\nconst rajdhani = Rajdhani({ \n  subsets: ['latin'],\n  weight: ['400', '500', '600', '700'],\n  variable: '--font-rajdhani',\n});\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <body className={`${rajdhani.variable} font-sans`}>{children}</body>\n    </html>\n  );\n}\n```\n\n3. Create a background component with animated cyberpunk effects:\n```tsx\n// components/CyberpunkBackground.tsx\nexport function CyberpunkBackground() {\n  return (\n    <div className=\"fixed inset-0 -z-10 overflow-hidden\">\n      <div className=\"absolute inset-0 bg-background\">\n        {/* Grid lines */}\n        <div className=\"absolute inset-0 opacity-10\" \n             style={{\n               backgroundImage: 'linear-gradient(0deg, transparent 24%, var(--primary) 25%, var(--primary) 26%, transparent 27%, transparent 74%, var(--primary) 75%, var(--primary) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, var(--primary) 25%, var(--primary) 26%, transparent 27%, transparent 74%, var(--primary) 75%, var(--primary) 76%, transparent 77%, transparent)',\n               backgroundSize: '50px 50px'\n             }}>\n        </div>\n        \n        {/* Animated glow */}\n        <div className=\"absolute inset-0 opacity-30\">\n          <div className=\"absolute -inset-[100%] animate-slow-spin bg-gradient-to-r from-transparent via-primary to-transparent blur-3xl\">\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Add to tailwind.config.js\n// animation: {\n//   'slow-spin': 'spin 20s linear infinite',\n// }\n```\n\n4. Create a ScoreDisplay component with animation effects:\n```tsx\n// components/ScoreDisplay.tsx\nimport { useState, useEffect } from 'react';\n\ninterface ScoreDisplayProps {\n  score: number;\n}\n\nexport function ScoreDisplay({ score }: ScoreDisplayProps) {\n  const [animate, setAnimate] = useState(false);\n  \n  useEffect(() => {\n    if (score > 0) {\n      setAnimate(true);\n      const timer = setTimeout(() => setAnimate(false), 300);\n      return () => clearTimeout(timer);\n    }\n  }, [score]);\n  \n  return (\n    <div className=\"relative\">\n      <span className={`text-xl font-bold ${animate ? 'text-glow scale-110' : ''} transition-all duration-300`}>\n        {score}\n      </span>\n    </div>\n  );\n}\n```\n\n5. Add particle effects for button presses and game events\n6. Implement smooth transitions between game states\n7. Create glitch effects for game over screen",
        "testStrategy": "1. Verify cyberpunk styling is applied consistently throughout the app\n2. Test animations for smoothness and performance on mobile devices\n3. Verify visual effects don't impact game performance\n4. Test that UI is readable and accessible despite stylistic effects\n5. Verify glow effects and animations work correctly\n6. Test particle effects for button presses\n7. Verify transitions between game states are smooth\n8. Test glitch effects on game over screen",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Mobile Optimization",
        "description": "Optimize the game for mobile devices, focusing on touch interactions, landscape orientation, and performance.",
        "details": "1. Add a screen orientation handler:\n```tsx\n// components/OrientationHandler.tsx\n'use client';\nimport { useState, useEffect } from 'react';\n\nexport function OrientationHandler() {\n  const [isLandscape, setIsLandscape] = useState(true);\n  \n  useEffect(() => {\n    const checkOrientation = () => {\n      if (window.innerWidth > window.innerHeight) {\n        setIsLandscape(true);\n      } else {\n        setIsLandscape(false);\n      }\n    };\n    \n    // Check on mount\n    checkOrientation();\n    \n    // Add listener for orientation changes\n    window.addEventListener('resize', checkOrientation);\n    window.addEventListener('orientationchange', checkOrientation);\n    \n    return () => {\n      window.removeEventListener('resize', checkOrientation);\n      window.removeEventListener('orientationchange', checkOrientation);\n    };\n  }, []);\n  \n  if (isLandscape) return null;\n  \n  return (\n    <div className=\"fixed inset-0 z-50 bg-background flex items-center justify-center p-6\">\n      <div className=\"text-center max-w-xs\">\n        <div className=\"mb-4 text-5xl\">üì±‚ÜîÔ∏è</div>\n        <h2 className=\"text-xl font-bold text-primary mb-2\">Please Rotate Your Device</h2>\n        <p className=\"text-white/80\">ReflexThis works best in landscape orientation for optimal gameplay experience.</p>\n      </div>\n    </div>\n  );\n}\n```\n\n2. Add the orientation handler to the game page:\n```tsx\n// app/game/page.tsx\nexport default function GamePage() {\n  // Existing code...\n  \n  return (\n    <>\n      <OrientationHandler />\n      <div className=\"min-h-screen bg-background text-white flex flex-col\">\n        {/* Game UI */}\n      </div>\n    </>\n  );\n}\n```\n\n3. Optimize touch events to reduce delay:\n```tsx\n// components/GameButton.tsx\nimport { useCallback, useEffect, useRef } from 'react';\n\nfunction GameButton({ id, highlighted, onPress }: GameButtonProps) {\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  \n  // Optimize touch events\n  useEffect(() => {\n    const button = buttonRef.current;\n    if (!button) return;\n    \n    // Prevent default touch behavior to avoid delays\n    const preventDefault = (e: Event) => {\n      e.preventDefault();\n    };\n    \n    button.addEventListener('touchstart', preventDefault, { passive: false });\n    button.addEventListener('touchend', preventDefault, { passive: false });\n    \n    return () => {\n      button.removeEventListener('touchstart', preventDefault);\n      button.removeEventListener('touchend', preventDefault);\n    };\n  }, []);\n  \n  // Use touchstart for faster response on mobile\n  const handlePress = useCallback(() => {\n    if (onPress) onPress();\n  }, [onPress]);\n  \n  return (\n    <button\n      ref={buttonRef}\n      className={`game-button w-16 h-16 md:w-20 md:h-20 rounded-full m-2 transition-all duration-300 \n        ${highlighted ? 'bg-primary shadow-glow animate-pulse' : 'bg-surface hover:bg-surface/80'}`}\n      onTouchStart={handlePress}\n      onClick={handlePress} // Keep for desktop\n      aria-label={`Game button ${id}`}\n    />\n  );\n}\n```\n\n4. Add meta tags for mobile optimization:\n```tsx\n// app/layout.tsx\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" />\n        <meta name=\"theme-color\" content=\"#0a0a0f\" />\n        <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n        <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" />\n      </head>\n      <body className={`${rajdhani.variable} font-sans`}>{children}</body>\n    </html>\n  );\n}\n```\n\n5. Implement performance optimizations:\n```tsx\n// Memoize components to prevent unnecessary re-renders\nconst GameButton = React.memo(function GameButton({ id, highlighted, onPress }: GameButtonProps) {\n  // Component code...\n});\n\n// Use useCallback for event handlers\nconst handleButtonPress = useCallback((buttonId: number) => {\n  // Handler code...\n}, [dependencies]);\n\n// Use useMemo for expensive calculations\nconst buttonLayout = useMemo(() => {\n  // Layout calculation...\n}, [dependencies]);\n```\n\n6. Add touch feedback effects\n7. Implement debouncing for button presses\n8. Add fullscreen mode for mobile browsers",
        "testStrategy": "1. Test game on various mobile devices (iOS and Android)\n2. Verify orientation handler works correctly\n3. Test touch responsiveness and ensure minimal delay\n4. Verify performance is smooth (60fps) during gameplay\n5. Test that meta tags prevent unwanted zooming and scaling\n6. Verify game is playable in both portrait and landscape modes\n7. Test fullscreen mode functionality\n8. Verify touch feedback effects work correctly\n9. Test debouncing prevents accidental double-taps",
        "priority": "high",
        "dependencies": [
          3,
          5,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Final Testing and Deployment",
        "description": "Perform comprehensive testing, fix bugs, optimize performance, and prepare the application for deployment.",
        "details": "1. Set up comprehensive testing:\n```tsx\n// Create test utilities and mock data\n// __tests__/utils.ts\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { GameProvider } from '@/lib/GameContext';\n\nexport function renderWithGameContext(ui: React.ReactElement) {\n  return {\n    user: userEvent.setup(),\n    ...render(<GameProvider>{ui}</GameProvider>)\n  };\n}\n```\n\n2. Create component tests:\n```tsx\n// __tests__/GameButton.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { GameButton } from '@/components/GameButton';\n\ndescribe('GameButton', () => {\n  test('renders correctly', () => {\n    const onPress = jest.fn();\n    render(<GameButton id={1} highlighted={false} onPress={onPress} />);\n    \n    const button = screen.getByRole('button');\n    expect(button).toBeInTheDocument();\n  });\n  \n  test('applies highlighted class when highlighted', () => {\n    render(<GameButton id={1} highlighted={true} onPress={() => {}} />);\n    \n    const button = screen.getByRole('button');\n    expect(button).toHaveClass('bg-primary');\n    expect(button).toHaveClass('shadow-glow');\n  });\n  \n  test('calls onPress when clicked', () => {\n    const onPress = jest.fn();\n    render(<GameButton id={1} highlighted={false} onPress={onPress} />);\n    \n    const button = screen.getByRole('button');\n    fireEvent.click(button);\n    \n    expect(onPress).toHaveBeenCalledTimes(1);\n  });\n});\n```\n\n3. Set up deployment configuration for Vercel:\n```json\n// vercel.json\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"package.json\",\n      \"use\": \"@vercel/next\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/$1\"\n    }\n  ],\n  \"env\": {\n    \"NEXT_PUBLIC_BUILD_DATE\": \"${VERCEL_GIT_COMMIT_SHA}\"\n  }\n}\n```\n\n4. Create a build script that includes version information:\n```js\n// scripts/build-info.js\nconst fs = require('fs');\nconst path = require('path');\n\nconst packageJson = require('../package.json');\nconst buildDate = new Date().toISOString();\nconst version = packageJson.version;\n\nconst buildInfo = {\n  version,\n  buildDate,\n  commitHash: process.env.VERCEL_GIT_COMMIT_SHA || 'development'\n};\n\nfs.writeFileSync(\n  path.join(__dirname, '../public/build-info.json'),\n  JSON.stringify(buildInfo, null, 2)\n);\n\nconsole.log('Build info generated:', buildInfo);\n```\n\n5. Update package.json to include the build script:\n```json\n\"scripts\": {\n  \"prebuild\": \"node scripts/build-info.js\",\n  \"build\": \"next build\",\n  \"start\": \"next start\",\n  \"dev\": \"next dev\",\n  \"lint\": \"next lint\",\n  \"test\": \"jest\"\n}\n```\n\n6. Create a performance monitoring utility:\n```tsx\n// lib/performance.ts\nexport function logPerformance(label: string) {\n  if (process.env.NODE_ENV !== 'production') return;\n  \n  const startTime = performance.now();\n  \n  return () => {\n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    console.log(`[Performance] ${label}: ${duration.toFixed(2)}ms`);\n  };\n}\n```\n\n7. Add error boundary component:\n```tsx\n// components/ErrorBoundary.tsx\n'use client';\nimport { Component, ErrorInfo, ReactNode } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class ErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(_: Error): State {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"min-h-screen flex items-center justify-center bg-background text-white p-4\">\n          <div className=\"text-center\">\n            <h2 className=\"text-2xl font-bold text-primary mb-4\">Something went wrong</h2>\n            <p className=\"mb-4\">The game encountered an error. Please try again.</p>\n            <button\n              onClick={() => this.setState({ hasError: false })}\n              className=\"btn-primary\"\n            >\n              Try Again\n            </button>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n```\n\n8. Add comprehensive browser testing\n9. Implement performance monitoring and optimization\n10. Create deployment pipeline",
        "testStrategy": "1. Run comprehensive test suite covering all components and game logic\n2. Test on multiple browsers (Chrome, Safari, Firefox, Edge)\n3. Test on various mobile devices (iOS and Android)\n4. Verify performance metrics meet requirements (load time < 3s, 60fps gameplay)\n5. Test error boundary functionality\n6. Verify build info is correctly generated and displayed\n7. Test deployment process to Vercel\n8. Perform accessibility testing\n9. Verify game works correctly in different network conditions\n10. Test PWA capabilities (if implemented)",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-20T13:37:01.746Z",
      "updated": "2025-11-20T13:53:59.077Z",
      "description": "Tasks for master context"
    }
  }
}